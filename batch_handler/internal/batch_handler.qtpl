{% func GenerateBatchHandler(data *handlerData) %}// Code generated by xvv, DO NOT EDIT.
// HandlerType: {%s data.HandlerType.String() %}

package {%s data.Package %}
{% code
name := data.Name
isBatched := data.IsBatched
handlerType := data.HandlerType

hasKey := handlerType.hasKey()
hasParams := data.ParamsType != nil
hasReturn := data.ValueType != nil

keyType := GetGoTypeName(data.KeyType)
keyTypeComma := ""
comma := ""
if hasKey && hasParams {
    keyTypeComma = keyType + ", "
    comma = ", "
} else if hasKey {
    keyTypeComma = keyType
}
paramsType := GetGoTypeName(data.ParamsType)
valueType := GetGoTypeName(data.ValueType)

valueTypeZeroValue := GetZeroValue(data.ValueType)

%}
import (
    "sync"
    "time"
{%- if hasKey && data.KeyType.ImportPath != "" -%}
    "{%s data.KeyType.ImportPath %}"
{%- endif -%}
{%- if hasParams && data.ParamsType.ImportPath != "" -%}
    "{%s data.ParamsType.ImportPath %}"
{%- endif -%}
{%- if hasReturn && data.ValueType.ImportPath != "" -%}
    "{%s data.ValueType.ImportPath %}"
{%- endif -%}
)

type {%s name %}Config struct {
{%- if isBatched -%}
    Do      func({%if hasKey%}keys []{%s keyTypeComma %}{%endif%}{%if hasParams%}paramsList []{%s paramsType %}{%endif%}) ({%if hasReturn%}[]{%s valueType %}, {%endif%}[]error)
{%- else -%}
    Do           func({%if hasKey%}key {%s keyTypeComma %}{%endif%}{%if hasParams%}params {%s paramsType %}{%endif%}) ({%if hasReturn%}{%s valueType %}, {%endif%}error)
{%- endif -%}
	Wait time.Duration
	MaxBatchSize int
{%- if handlerType.hasCacheDel() -%}
    CacheDel func(keys ...{%s keyType %}) error
{%- endif -%}
{%- if handlerType.hasCacheGet() -%}
    {%- if isBatched -%}
    CacheBatchGet func(keys []{%s keyType %}) ({%if hasReturn%}[]{%s valueType %}, {%endif%}error)
    {%- else -%}
    CacheGet func(key {%s keyType %}) ({%if hasReturn%}{%s valueType %}, {%endif%}error)
    {%- endif -%}
{%- endif -%}
{%- if handlerType.hasCacheSet() -%}
    {%- if isBatched -%}
    CacheBatchSet func(keys []{%s keyType %}{%if hasReturn%}, items []{%s valueType %}{%endif%}) error
    {%- else -%}
    CacheSet func(key {%s keyType %}{%if hasReturn%}, items {%s valueType %}{%endif%}) error
    {%- endif -%}
{%- endif -%}
}

type {%s name %} struct {
{%- if isBatched -%}
    Do      func({%if hasKey%}keys []{%s keyTypeComma %}{%endif%}{%if hasParams%}paramsList []{%s paramsType %}{%endif%}) ({%if hasReturn%}[]{%s valueType %}, {%endif%}[]error)
{%- else -%}
    Do           func({%if hasKey%}key {%s keyTypeComma %}{%endif%}{%if hasParams%}params {%s paramsType %}{%endif%}) ({%if hasReturn%}{%s valueType %}, {%endif%}error)
{%- endif -%}
    Wait         time.Duration
    MaxBatchSize int
{%- if handlerType.hasCacheDel() -%}
    CacheDel func(keys ...{%s keyType %}) error
{%- endif -%}
{%- if handlerType.hasCacheGet() -%}
    {%- if isBatched -%}
    CacheBatchGet func(keys []{%s keyType %}) ({%if hasReturn%}[]{%s valueType %}, {%endif%}error)
    {%- else -%}
    CacheGet func(key {%s keyType %}) ({%if hasReturn%}{%s valueType %}, {%endif%}error)
    {%- endif -%}
{%- endif -%}
{%- if handlerType.hasCacheSet() -%}
    {%- if isBatched -%}
    CacheBatchSet func(keys []{%s keyType %}{%if hasReturn%}, items []{%s valueType %}{%endif%}) error
    {%- else -%}
    CacheSet func(key {%s keyType %}{%if hasReturn%}, items {%s valueType %}{%endif%}) error
    {%- endif -%}
{%- endif -%}
    batch *{%s lcFirst(data.Name) %}Batch
    m sync.Mutex
}

func New{%s name %}(config {%s name %}Config) *{%s name %} {
	return &{%s name %}{
		Do: config.Do,
		Wait: config.Wait,
		MaxBatchSize: config.MaxBatchSize,
    {%- if handlerType.hasCacheDel() -%}
        CacheDel: config.CacheDel,
    {%- endif -%}
    {%- if handlerType.hasCacheGet() -%}
        {%- if isBatched -%}
        CacheBatchGet: config.CacheBatchGet,
        {%- else -%}
        CacheGet: config.CacheGet,
        {%- endif -%}
    {%- endif -%}
    {%- if handlerType.hasCacheSet() -%}
        {%- if isBatched -%}
        CacheBatchSet: config.CacheBatchSet,
        {%- else -%}
        CacheSet: config.CacheSet,
        {%- endif -%}
    {%- endif -%}
	}
}

{%-if isBatched -%}
func (s *{%s name %}) Query({%if hasKey%}key {%s keyTypeComma %}{%endif%}{% if hasParams%}params {%s paramsType %}{% endif %}) ({% if hasReturn %}{%s valueType %}, {% endif %}error) {
	return s.QueryFuture({%if hasKey%}key{%endif%}{%s comma%}{% if hasParams%}params{% endif %})()
}

func (s *{%s name %}) QueryFuture({%if hasKey%}key {%s keyTypeComma %}{%endif%}{% if hasParams%}params {%s paramsType %}{% endif %}) func() ({% if hasReturn %}{%s valueType %}, {% endif %}error) {
	s.m.Lock()
	if s.batch == nil {
		s.batch = &{%s lcFirst(data.Name) %}Batch{done: make(chan struct{})}
	}
	batch := s.batch
	pos := batch.getPosition(s, {%if hasKey%}key{%endif%}{%s comma%}{% if hasParams%}params{% endif %})
	s.m.Unlock()

	return func() ({% if hasReturn %}{%s valueType %}, {% endif %}error) {
		<-batch.done
{%- if hasReturn -%}
		var data {%s valueType %}
		if pos < len(batch.data) {
			data = batch.data[pos]
		}
{%- endif -%}
		var err error
		// its convenient to be able to return a single error for everything
		if len(batch.error) == 1 {
			err = batch.error[0]
		} else if batch.error != nil {
			err = batch.error[pos]
		}

		return {%if hasReturn %}data, {%endif%}err
	}
}

func (s *{%s name %}) QueryAll({%if hasKey%}keys []{%s keyTypeComma %}{%endif%}{% if hasParams%}paramsList []{%s paramsType %}{% endif %}) ({% if hasReturn %}[]{%s valueType %}, {% endif %}[]error) {
	return s.QueryAllFuture({%if hasKey%}keys{%endif%}{%s comma%}{% if hasParams%}paramsList{% endif %})()
}

func (s *{%s name %}) QueryAllFuture({%if hasKey%}keys []{%s keyTypeComma %}{%endif%}{% if hasParams%}paramsList []{%s paramsType %}{% endif %}) func() ({% if hasReturn %}[]{%s valueType %}, {% endif %}[]error) {
	thunks := make([]func() ({% if hasReturn %}{%s valueType %}, {% endif %}error), len({%if hasKey%}keys{%else%}paramsList{%endif%}))
	for i, item := range {%if hasKey%}keys{%else%}paramsList{%endif%} {
        thunks[i] = s.QueryFuture(item{%if hasKey && hasParams %}, paramsList[i]{%endif%})
	}

	return func() ({% if hasReturn %}[]{%s valueType %}, {% endif %}[]error) {
		errors := make([]error, len({%if hasKey%}keys{%else%}paramsList{%endif%}))
{%- if hasReturn -%}
        results := make([]{%s valueType %}, len({%if hasKey%}keys{%else%}paramsList{%endif%}))
        for i, thunk := range thunks {
            results[i], errors[i] = thunk()
        }
        return results, errors
{%- else -%}
        for i, thunk := range thunks {
            errors[i] = thunk()
        }
        return errors
{%- endif -%}
	}
}
{%- endif -%}
{%- if !isBatched -%}
func (s *{%s name %}) Query({%if hasKey%}key {%s keyTypeComma %}{%endif%}{% if hasParams%}params {%s paramsType %}{% endif %}) ({% if hasReturn %}{%s valueType %}, {% endif %}error) {
	return s.QueryFuture({%if hasKey%}key{%endif%}{%s comma%}{% if hasParams%}params{% endif %})()
}

func (s *{%s name %}) QueryFuture({%if hasKey%}key {%s keyTypeComma %}{%endif%}{% if hasParams%}params {%s paramsType %}{% endif %}) func() ({% if hasReturn %}{%s valueType %}, {% endif %}error) {
	s.m.Lock()
	if s.batch == nil {
		s.batch = &{%s lcFirst(name) %}Batch{done: make(chan struct{})}
	}
	singleFunc := s.batch.getSingleFunc(s, {%if hasKey%}key{%endif%}{%s comma%}{% if hasParams%}params{% endif %})
	s.m.Unlock()
	return singleFunc
}
{%- endif -%}

type {%s lcFirst(name) %}Batch struct {
{%- if hasKey -%}
	keys       []{%s keyType %}
{%- endif -%}
{%- if hasParams -%}
	paramsList []{%s paramsType %}
{%- endif -%}
{%- if hasReturn -%}
	data []{%s valueType %}
{%- endif -%}
	error      []error
{%- if !isBatched -%}
	funcs  []func() ({% if hasReturn%}{%s valueType %}, {% endif %}error)
	funcDoneList []chan struct{}
{%- endif -%}
	closing    bool
	done       chan struct{}
}

{%- if isBatched -%}
func (s *{%s lcFirst(name) %}Batch) getPosition(handler *{%s name %}, {%if hasKey%}key {%s keyTypeComma %}{%endif%}{% if hasParams%}params {%s paramsType %}{% endif %}) int {
{%- if hasKey -%}
	for i, existingKey := range s.keys {
		if key == existingKey {
			return i
		}
	}
    pos := len(s.keys)
    s.keys = append(s.keys, key)
{%- else -%}
    pos := len(s.paramsList)
{%- endif -%}
{%- if hasParams -%}
	s.paramsList = append(s.paramsList, params)
{%- endif -%}
	if pos == 0 {
		go s.waiting(handler)
	}

	if handler.MaxBatchSize != 0 && pos >= handler.MaxBatchSize-1 {
		if !s.closing {
			s.closing = true
			handler.batch = nil
			go s.finish(handler)
		}
	}

	return pos
}
{%- endif -%}
{%- if !isBatched -%}
func (s *{%s lcFirst(name) %}Batch) getSingleFunc(handler *{%s name %}, {%if hasKey%}key {%s keyTypeComma %}{%endif%}{% if hasParams%}params {%s paramsType %}{% endif %}) func() ({% if hasReturn %}{%s valueType %}, {% endif %}error) {
{%- if hasKey -%}
	for i, existingKey := range s.keys {
		if key == existingKey {
			pos := i
			return func() ({% if hasReturn %}{%s valueType %}, {% endif %}error) {
				<- s.funcDoneList[pos]
				return {% if hasReturn %}s.data[pos], {% endif %}s.error[pos]
			}
		}
	}
	pos := len(s.keys)
	s.keys = append(s.keys, key)
{%- else -%}
    pos := len(s.funcDoneList)
{%- endif -%}
	funcDone := make(chan struct{})
	s.funcDoneList = append(s.funcDoneList, funcDone)
{%- if hasReturn -%}
	s.data = append(s.data, {%s= valueTypeZeroValue %})
{%- endif -%}
	s.error = append(s.error, nil)

	singleFunc := func() ({% if hasReturn %}{%s valueType %}, {% endif %}error) {
		<- s.done
        {% if hasReturn %}var item {%s valueType %}{% endif %}
        var err error

{%-if handlerType.hasCacheGet()-%}
        fromCache := false
        if handler.CacheGet != nil {
            if item, err = handler.CacheGet(key); err == nil {
                fromCache = true
            }
        }
        if !fromCache {
            item, err = handler.Do({%if hasKey%}key{%endif%}{%s comma%}{% if hasParams%}params{% endif %})
        }
{%-else-%}
        {% if hasReturn %}item, {% endif %}err = handler.Do({%if hasKey%}key{%endif%}{%s comma%}{% if hasParams%}params{% endif %})
{%-endif-%}
{%- if hasReturn -%}
        s.data[pos] = item
{%- endif -%}
		s.error[pos] = err
		close(funcDone)

{%- if handlerType.hasCacheSet() -%}
        if !fromCache && err == nil && handler.CacheSet != nil {
            _ = handler.CacheSet(key, item)
        }
{%- endif -%}
{%- if handlerType.hasCacheDel() -%}
        if handler.CacheDel != nil {
            _ = handler.CacheDel(key)
        }
{%- endif -%}
		return {% if hasReturn %}item, {% endif %}err
	}

	s.funcs = append(s.funcs, singleFunc)

	if pos == 0 {
		go s.waiting(handler)
	}

	if handler.MaxBatchSize != 0 && pos >= handler.MaxBatchSize-1 {
		if !s.closing {
			s.closing = true
			handler.batch = nil
			close(s.done)
		}
	}

	return singleFunc
}
{%- endif -%}

func (s *{%s lcFirst(name) %}Batch) waiting(handler *{%s name %}) {
	time.Sleep(handler.Wait)
	handler.m.Lock()
	if s.closing {
		handler.m.Unlock()
		return
	}
	handler.batch = nil
	handler.m.Unlock()

{%- if isBatched -%}
	s.finish(handler)
{%- else -%}
	close(s.done)
{%- endif -%}
}

{%- if isBatched -%}
func (s *{%s lcFirst(name) %}Batch) finish(handler *{%s name %}) {
{%-if hasKey && hasReturn && handlerType.hasCacheGet() -%}
    if s.fetchItemsWithCache(handler) {
		return
	}
{%-endif-%}
    {%if hasReturn%}s.data, {%endif%}s.error = handler.Do({%if hasKey%}s.keys{%endif%}{%s comma%}{%if hasParams%}s.paramsList{%endif%})
	close(s.done)

{%- if hasKey && hasReturn && handlerType.hasCacheSet() -%}
	if handler.CacheBatchSet != nil {
		if len(s.error) == 0 {
			_ = handler.CacheBatchSet(s.keys, s.data)
			return
		}
		var keys []{%s keyType %}
		var data []{%s valueType %}

		for i, err := range s.error {
			if err == nil {
				keys = append(keys, s.keys[i])
				data = append(data, s.data[i])
			}
		}

		if len(keys) > 0 {
			_ = handler.CacheBatchSet(keys, data)
			return
		}
	}
{%- endif -%}
{%- if handlerType.hasCacheDel() -%}
    if handler.CacheDel != nil {
        _ = handler.CacheDel(s.keys...)
    }
{%- endif -%}
}

{%- if hasKey && hasReturn && handlerType.hasCacheGet() -%}
func (s *{%s lcFirst(name) %}Batch) fetchItemsWithCache(handler *{%s name %}) bool {
	if handler.CacheBatchGet == nil {
		return false
	}
	items, err := handler.CacheBatchGet(s.keys)
	if err != nil {
		return false
	}
    // collect nil items and fetch data with handle.Do
{%- if hasKey -%}
	newKeys := make([]{%s keyType %}, 0, 8)
{%- endif -%}
{%- if hasParams -%}
    params := make([]{%s paramsType %}, 0, 8)
{%- endif -%}
	for i, item := range items {
		if item == nil {
{%- if hasKey -%}
			newKeys = append(newKeys, s.keys[i])
{%- endif -%}
{%- if hasParams -%}
			params = append(params, s.paramsList[i])
{%- endif -%}
		}
	}

    if len(newKeys) == 0 {
		s.data, s.error = items, nil
		close(s.done)
		return true
	}

	finalErrs := make([]error, len(items))
	newItems, errs := handler.Do(newKeys{%if hasParams%}, params{%endif%})
	idx := 0
	for i, item := range items {
		if item == nil {
			items[i] = newItems[idx]
			if len(errs) == 1 {
				finalErrs[i] = errs[0]
			} else if errs != nil {
				finalErrs[i] = errs[idx]
			}
			idx++
		}
	}
	// set and notify
    s.data, s.error = items, errs
    close(s.done)

    if errs == nil && handler.CacheBatchSet != nil {
        _ = handler.CacheBatchSet(newKeys, newItems)
    }
    return true
}

{%-endif-%}


{%- endif -%}
{% endfunc %}
