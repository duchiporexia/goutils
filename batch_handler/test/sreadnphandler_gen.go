// Code generated by xvv, DO NOT EDIT.
// HandlerType: Read

package test

import (
	"sync"
	"time"

	"github.com/duchiporexia/goutils/batch_handler/test/dto"
)

type SReadNpHandlerConfig struct {
	Do           func(key string) (*dto.Dog, error)
	Wait         time.Duration
	MaxBatchSize int
	CacheGet     func(key string) (*dto.Dog, error)
	CacheSet     func(key string, items *dto.Dog) error
}

type SReadNpHandler struct {
	Do           func(key string) (*dto.Dog, error)
	Wait         time.Duration
	MaxBatchSize int
	CacheGet     func(key string) (*dto.Dog, error)
	CacheSet     func(key string, items *dto.Dog) error
	batch        *sReadNpHandlerBatch
	m            sync.Mutex
}

func NewSReadNpHandler(config SReadNpHandlerConfig) *SReadNpHandler {
	return &SReadNpHandler{
		Do:           config.Do,
		Wait:         config.Wait,
		MaxBatchSize: config.MaxBatchSize,
		CacheGet:     config.CacheGet,
		CacheSet:     config.CacheSet,
	}
}

func (s *SReadNpHandler) Query(key string) (*dto.Dog, error) {
	return s.QueryFuture(key)()
}

func (s *SReadNpHandler) QueryFuture(key string) func() (*dto.Dog, error) {
	s.m.Lock()
	if s.batch == nil {
		s.batch = &sReadNpHandlerBatch{done: make(chan struct{})}
	}
	singleFunc := s.batch.getSingleFunc(s, key)
	s.m.Unlock()
	return singleFunc
}

type sReadNpHandlerBatch struct {
	keys         []string
	data         []*dto.Dog
	error        []error
	funcs        []func() (*dto.Dog, error)
	funcDoneList []chan struct{}
	closing      bool
	done         chan struct{}
}

func (s *sReadNpHandlerBatch) getSingleFunc(handler *SReadNpHandler, key string) func() (*dto.Dog, error) {
	for i, existingKey := range s.keys {
		if key == existingKey {
			pos := i
			return func() (*dto.Dog, error) {
				<-s.funcDoneList[pos]
				return s.data[pos], s.error[pos]
			}
		}
	}
	pos := len(s.keys)
	s.keys = append(s.keys, key)
	funcDone := make(chan struct{})
	s.funcDoneList = append(s.funcDoneList, funcDone)
	s.data = append(s.data, nil)
	s.error = append(s.error, nil)

	singleFunc := func() (*dto.Dog, error) {
		<-s.done
		var item *dto.Dog
		var err error

		fromCache := false
		if handler.CacheGet != nil {
			if item, err = handler.CacheGet(key); err == nil {
				fromCache = true
			}
		}
		if !fromCache {
			item, err = handler.Do(key)
		}
		s.data[pos] = item
		s.error[pos] = err
		close(funcDone)

		if !fromCache && err == nil && handler.CacheSet != nil {
			_ = handler.CacheSet(key, item)
		}
		return item, err
	}

	s.funcs = append(s.funcs, singleFunc)

	if pos == 0 {
		go s.waiting(handler)
	}

	if handler.MaxBatchSize != 0 && pos >= handler.MaxBatchSize-1 {
		if !s.closing {
			s.closing = true
			handler.batch = nil
			close(s.done)
		}
	}

	return singleFunc
}

func (s *sReadNpHandlerBatch) waiting(handler *SReadNpHandler) {
	time.Sleep(handler.Wait)
	handler.m.Lock()
	if s.closing {
		handler.m.Unlock()
		return
	}
	handler.batch = nil
	handler.m.Unlock()

	close(s.done)
}
